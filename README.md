TimerPro: AI-Powered Urgency for ShopifyThis project was built for the Shopify Developer Assessment. It‚Äôs a full-stack MERN application that allows merchants to deploy high-conversion countdown timers‚Äîboth global "Flash Sales" and personalized "Evergreen" sessions‚Äîusing AI to handle the marketing copy.üöÄ Setup InstructionsEnvironment Variables: Create a .env file in the web/ directory with:MONGODB_URI: Your Atlas connection string.OPENAIROUTER_API_KEY: Your OpenRouter key.OPENAI_MODEL_NAME: e.g., openai/gpt-3.5-turbo.Install Dependencies: Run npm install in the root directory.Local Dev: Run npm run dev. This will launch the Shopify CLI, sync the Theme App Extension, and start the Node.js backend.Preview: Open your development store and add the "Global Flash Sale" block via the Theme Editor.üèóÔ∏è Architecture Decisions1. The MERN Pattern & Multi-TenancyI chose the MERN stack (MongoDB, Express, React, Node) to maintain a clear separation of concerns. 1Data Isolation: Every document in the MongoDB collection is indexed by the shop domain. 2This ensures that even in a multi-tenant environment, a merchant's data is isolated and lookups remain $O(1)$3.+1Schema Flexibility: I used a single Timer model to handle two different logic types. By storing the endDate as a string, I can toggle between a static ISO date for "Fixed" timers and a minute-duration for "Evergreen" timers.2. Storefront: Theme App Extensions vs. ScriptTagsInstead of using legacy ScriptTags, I used Theme App Extensions. 4 This is a critical performance decision:Performance: Extensions allow Shopify to manage the liquid rendering, which helps avoid Cumulative Layout Shift (CLS). 5App Proxy: I used an App Proxy to bridge the storefront and my backend. 6666This avoids CORS issues and allows for secure, authenticated data fetching. 7+2üß† AI Strategy & OpenRouterFor the AI requirement, I integrated OpenRouter to provide an "Assistant" experience in the admin dashboard.Model Choice: I used GPT-3.5/4o-mini models. They offer the best balance between creative marketing copy and low latency. 8Assistance vs. Automation: Following the PRD, the AI generates suggestions (Title, Description, Duration) based on merchant intent, but it never auto-saves. 9999The merchant must review and edit the copy before it goes live. 10+2Trade-offs: While calling an LLM adds about 1‚Äì2 seconds of latency to the dashboard, the value of having "pre-written" high-converting copy outweighs the slight delay. 11üõ†Ô∏è Assumptions & Trade-offsEvergreen Persistence: I assumed that localStorage is the best balance for session tracking. 12While a cookie-based server-side session is more "secure," localStorage provides a zero-latency experience for the customer. 13+1Analytics: I chose to track "Impressions" (views). 14141414In a production app, I would also track "Conversions" (clicks/sales) to show the merchant a true ROI. 15+2Styling: I opted for Tailwind-style CSS within the Liquid block to keep the bundle size under the 30KB limit specified in the PRD. 16üìà What I‚Äôd Improve with More TimeUnit Testing: I would implement at least 5 meaningful unit tests covering the Evergreen time calculation and the API input sanitization. 17Smart Scheduling: I'd enhance the AI to suggest specific "Power Hours" for the sale based on the store's peak traffic times. 18A/B Testing: Allowing merchants to run two AI-generated headlines simultaneously to see which drives more urgency. 19
